)]}'
{"version":3,"sources":["vsivsi:file-collection/resumable/resumable.js","vsivsi:file-collection/src/gridFS.coffee","vsivsi:file-collection/src/resumable_client.coffee","vsivsi:file-collection/src/gridFS_client.coffee"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,E;AACA,c;AACA,uC;AACA,mC;AACA,sD;AACA,E;;AAEA,Y;AACA,a;;AAEA,iC;AACA,yC;AACA,iC;AACA,K;AACA,uB;AACA,4B;AACA,0D;AACA,yB;AACA,yB;AACA,6B;AACA,sB;AACA,oB;AACA,+C;AACA,qB;AACA,+C;AACA,qB;AACA,mD;AACA,qB;AACA,2G;AACA,qB;AACA,oC;;;AAGA,iB;AACA,iB;AACA,iB;AACA,kB;AACA,4B;AACA,2B;AACA,4B;AACA,+B;AACA,oC;AACA,e;AACA,iB;AACA,sB;AACA,yB;AACA,wC;AACA,iB;AACA,4B;AACA,sB;AACA,oC;AACA,gC;AACA,mC;AACA,gD;AACA,yB;AACA,4B;AACA,mB;AACA,0D;AACA,4C;AACA,mG;AACA,Q;AACA,oB;AACA,2D;AACA,0I;AACA,Q;AACA,4B;AACA,2D;AACA,wI;AACA,Q;AACA,mB;AACA,yD;AACA,4H;AACA,O;AACA,M;AACA,sB;AACA,4B;AACA,sB;AACA,+C;AACA,8B;AACA,yB;AACA,oC;AACA,gD;AACA,W;AACA,uB;AACA,O;AACA,+C;AACA,2C;AACA,yE;AACA,qC;AACA,O;AACA,0C;AACA,yE;AACA,0C;AACA,O;AACA,sC;AACA,yE;AACA,yC;AACA,O;AACA,M;;AAEA,a;AACA,2B;AACA,gH;AACA,4D;AACA,kB;AACA,oC;AACA,mD;AACA,M;AACA,wB;AACA,wD;AACA,oB;AACA,qE;AACA,kE;AACA,wC;AACA,+C;AACA,oE;AACA,mE;AACA,O;AACA,+D;AACA,mD;AACA,M;;;AAGA,4E;AACA,c;AACA,6B;AACA,4B;AACA,2B;AACA,Q;AACA,iC;AACA,4C;AACA,0C;AACA,gC;AACA,8C;AACA,W;AACA,gB;AACA,wB;AACA,qB;AACA,gD;AACA,W;AACA,S;AACA,Q;AACA,8C;AACA,0D;AACA,0C;AACA,8B;AACA,S;AACA,gI;AACA,6B;AACA,2E;AACA,Q;AACA,qC;AACA,2B;;AAEA,wC;AACA,8B;AACA,0B;AACA,yB;AACA,W;AACA,sB;AACA,W;;AAEA,sB;AACA,Q;AACA,gC;AACA,uB;AACA,iC;AACA,mC;AACA,kD;AACA,wC;AACA,yD;AACA,gB;AACA,gE;AACA,S;AACA,Q;AACA,iC;AACA,wC;AACA,qC;AACA,wB;AACA,gB;AACA,wB;AACA,S;AACA,yC;AACA,O;AACA,M;;AAEA,iC;AACA,0B;;AAEA,qG;AACA,2D;AACA,mD;AACA,O;AACA,iC;AACA,gE;AACA,mD;AACA,O;AACA,M;AACA,sC;AACA,yB;AACA,M;;AAEA,uE;AACA,O;AACA,2I;AACA,8H;AACA,uI;AACA,yG;AACA,yG;AACA,oD;AACA,qG;AACA,8I;AACA,O;AACA,yD;AACA,uD;AACA,mB;AACA,iB;AACA,mB;AACA,oB;AACA,sB;AACA,U;AACA,O;;AAEA,4D;AACA,4C;;AAEA,iF;AACA,8C;AACA,4B;AACA,0B;;AAEA,8C;AACA,oF;AACA,uB;AACA,S;AACA,mC;AACA,0H;AACA,oC;AACA,S;AACA,yC;AACA,qG;AACA,0C;AACA,S;AACA,wD;AACA,+E;AACA,6D;AACA,iI;AACA,mB;AACA,S;AACA,gD;AACA,yE;AACA,iD;AACA,iI;AACA,mB;AACA,S;AACA,c;AACA,6G;AACA,sC;AACA,mB;AACA,S;;AAEA,qB;AACA,oF;AACA,sC;AACA,S;AACA,gC;AACA,gJ;AACA,2E;AACA,qC;AACA,mD;AACA,4B;AACA,8B;AACA,a;AACA,S;AACA,qC;AACA,uJ;AACA,2E;AACA,wC;;AAEA,gC;AACA,yF;AACA,yC;AACA,mC;AACA,yE;AACA,sC;AACA,8C;AACA,iF;AACA,iG;AACA,oG;AACA,oD;AACA,yB;AACA,8B;AACA,gH;AACA,sE;AACA,0G;AACA,wD;AACA,yB;AACA,sB;AACA,mG;AACA,mC;AACA,sG;AACA,oD;AACA,0C;AACA,qB;AACA,kB;AACA,c;AACA,S;AACA,O;AACA,M;;AAEA,O;AACA,4E;AACA,4G;AACA,uG;AACA,mG;AACA,O;AACA,qD;AACA,8B;;AAEA,wE;AACA,+C;AACA,0D;AACA,O;AACA,M;;AAEA,O;AACA,4H;AACA,kG;AACA,mG;AACA,kJ;AACA,O;AACA,2D;AACA,qE;AACA,2D;AACA,6B;;AAEA,wE;AACA,+C;AACA,0D;AACA,O;AACA,M;;AAEA,4D;AACA,2C;AACA,yB;AACA,yL;AACA,4F;AACA,4H;AACA,0E;AACA,mC;AACA,gB;AACA,0D;AACA,uB;AACA,S;AACA,O;AACA,qB;AACA,uC;AACA,iC;AACA,kC;AACA,6B;AACA,gC;AACA,4C;AACA,+E;AACA,0B;AACA,W;AACA,K;AACA,I;AACA,wB;AACA,iD;AACA,kB;AACA,I;AACA,G;;AAEA,6E;AACA,yD;AACA,uB;AACA,S;AACA,6E;AACA,yD;AACA,uB;AACA,S;;AAEA,2C;AACA,yE;AACA,qD;AACA,iE;AACA,4B;AACA,0B;AACA,kF;AACA,yC;AACA,2C;AACA,iB;AACA,gB;AACA,S;AACA,qC;AACA,gE;AACA,2H;AACA,0B;AACA,2C;AACA,wC;AACA,Y;AACA,2B;AACA,wB;AACA,a;AACA,c;AACA,oC;AACA,S;;AAEA,S;AACA,mC;AACA,mC;AACA,W;AACA,M;;AAEA,4B;AACA,iE;AACA,mB;AACA,kB;AACA,qC;AACA,0B;AACA,oC;AACA,oB;AACA,+F;AACA,yB;AACA,kF;AACA,4C;AACA,uB;AACA,uB;AACA,kD;;AAEA,yD;AACA,gD;AACA,iE;AACA,sB;AACA,wB;AACA,iD;AACA,gB;AACA,qB;AACA,oB;AACA,wB;AACA,wB;AACA,uD;AACA,gB;AACA,uB;AACA,4B;AACA,2E;AACA,8B;AACA,2D;AACA,W;AACA,gB;AACA,qB;AACA,8C;AACA,gB;AACA,S;AACA,Q;;AAEA,uD;AACA,yD;AACA,oB;AACA,2B;AACA,+B;AACA,2B;AACA,sC;AACA,uC;AACA,sB;AACA,yB;AACA,W;AACA,W;AACA,gE;AACA,Q;AACA,4B;AACA,qC;AACA,+B;AACA,sB;AACA,+B;AACA,qC;AACA,wC;AACA,sB;AACA,6C;AACA,W;AACA,W;AACA,qC;AACA,+C;AACA,Q;AACA,2B;AACA,sB;AACA,+B;AACA,yD;AACA,kD;AACA,4B;AACA,W;AACA,Q;AACA,+B;AACA,kB;AACA,uB;AACA,4C;AACA,sB;AACA,4B;AACA,wE;AACA,6E;AACA,0E;AACA,yC;AACA,yF;AACA,2E;AACA,iB;AACA,mB;AACA,qC;AACA,sD;AACA,a;AACA,Q;AACA,8B;AACA,6B;AACA,4C;AACA,oB;AACA,0B;AACA,sC;AACA,+C;AACA,gF;AACA,W;AACA,oD;AACA,2G;AACA,8B;AACA,oB;AACA,Q;AACA,iC;AACA,8B;AACA,0C;AACA,2C;AACA,6B;AACA,0B;AACA,W;AACA,W;AACA,0B;AACA,Q;AACA,gC;AACA,gC;AACA,0C;AACA,sC;AACA,uF;AACA,+B;AACA,0B;AACA,W;AACA,W;AACA,6B;AACA,Q;AACA,gC;AACA,0C;AACA,mD;AACA,gB;AACA,+B;AACA,W;AACA,Q;AACA,+B;AACA,wB;AACA,Q;;;AAGA,6B;AACA,8C;AACA,oB;AACA,mB;AACA,K;;;AAGA,qE;AACA,mB;AACA,kB;AACA,qC;AACA,oC;AACA,0B;AACA,mC;AACA,wC;AACA,wB;AACA,4B;AACA,0C;AACA,uB;AACA,oB;AACA,6B;AACA,6E;;AAEA,4B;AACA,4C;AACA,mB;AACA,uC;AACA,kE;AACA,+E;AACA,uF;AACA,kC;AACA,O;AACA,mB;;AAEA,wH;AACA,0B;AACA,8C;AACA,qC;;AAEA,sC;AACA,0B;AACA,kC;AACA,iC;AACA,4C;AACA,6C;AACA,kB;AACA,qB;AACA,W;AACA,U;AACA,2D;AACA,4D;AACA,8D;;AAEA,0C;AACA,wB;AACA,gE;AACA,4C;AACA,qF;AACA,2C;AACA,mG;AACA,W;AACA,2C;AACA,2G;AACA,oH;AACA,6H;AACA,4G;AACA,uG;AACA,0H;AACA,gH;AACA,wH;AACA,wH;AACA,gD;AACA,gD;AACA,+C;AACA,4D;AACA,uC;AACA,oD;AACA,uC;AACA,W;AACA,yB;AACA,Q;;AAEA,wC;AACA,8B;AACA,iB;AACA,Q;;AAEA,sD;AACA,0B;AACA,gD;AACA,8C;AACA,qC;AACA,+D;AACA,yB;AACA,wB;AACA,W;AACA,S;AACA,iD;AACA,mB;AACA,iB;AACA,S;;AAEA,8C;AACA,qC;;AAEA,mB;AACA,8D;AACA,oG;AACA,mC;AACA,gD;AACA,W;AACA,+B;AACA,kB;AACA,qB;AACA,+B;AACA,+B;;AAEA,8C;AACA,sC;AACA,kC;AACA,kD;AACA,4C;AACA,6C;AACA,kB;AACA,6C;AACA,sB;AACA,wB;AACA,+D;AACA,6C;AACA,oC;AACA,gD;AACA,oB;AACA,uB;AACA,a;AACA,W;AACA,U;AACA,2D;AACA,4D;AACA,8D;;AAEA,qD;AACA,qB;AACA,2C;AACA,oD;AACA,6D;AACA,4C;AACA,uC;AACA,0D;AACA,gD;AACA,wD;AACA,uD;AACA,U;AACA,6B;AACA,4C;AACA,qF;AACA,2C;AACA,uB;AACA,W;;AAEA,wJ;AACA,6D;AACA,sB;AACA,oC;;AAEA,gE;AACA,6C;AACA,4C;AACA,uB;AACA,0B;AACA,uC;AACA,qG;AACA,a;AACA,wC;AACA,gB;AACA,4C;AACA,gC;AACA,uC;AACA,gD;AACA,a;AACA,+E;AACA,S;;AAEA,mC;AACA,+C;AACA,4D;AACA,uC;AACA,oD;AACA,uC;AACA,W;AACA,yB;AACA,Q;AACA,2B;AACA,0B;AACA,gC;AACA,qB;AACA,Q;AACA,4B;AACA,8D;AACA,4B;AACA,qF;AACA,uE;AACA,8B;AACA,2B;AACA,4B;AACA,uC;AACA,yG;AACA,8B;AACA,gB;AACA,iC;AACA,gC;AACA,8B;AACA,yH;AACA,gD;AACA,4B;AACA,kB;AACA,0E;AACA,sE;AACA,sB;AACA,8B;AACA,W;AACA,S;AACA,Q;AACA,6B;AACA,gD;AACA,Q;AACA,sC;AACA,4D;AACA,4E;AACA,qC;AACA,2B;AACA,kB;AACA,uB;AACA,qB;AACA,2B;AACA,uB;AACA,2B;AACA,gB;AACA,0D;AACA,S;AACA,Q;AACA,mB;AACA,K;;AAEA,Y;AACA,mC;AACA,wB;;AAEA,6E;AACA,iF;AACA,sE;AACA,oD;AACA,wC;AACA,gH;AACA,kC;AACA,yB;AACA,0B;AACA,W;AACA,wJ;AACA,qD;AACA,yB;AACA,0B;AACA,W;AACA,W;AACA,+B;AACA,O;;AAEA,4D;AACA,sC;AACA,oC;AACA,8C;AACA,yE;AACA,0B;AACA,0B;AACA,2B;AACA,Y;AACA,a;AACA,S;AACA,gC;AACA,S;AACA,6B;;AAEA,kF;AACA,8B;AACA,sC;AACA,gC;AACA,6B;AACA,wB;AACA,S;AACA,S;AACA,wB;AACA,kD;AACA,2B;AACA,O;AACA,oB;AACA,M;;;AAGA,sC;AACA,qD;AACA,qE;;AAEA,2C;AACA,kB;AACA,+D;AACA,0B;AACA,gB;AACA,kD;AACA,6C;AACA,uC;AACA,uD;AACA,oC;AACA,wC;AACA,0B;AACA,0B;AACA,uC;AACA,oB;AACA,qC;AACA,S;AACA,4C;AACA,yD;AACA,qD;AACA,gB;AACA,4C;AACA,S;AACA,wB;AACA,mE;AACA,gB;AACA,mD;AACA,S;AACA,2E;AACA,qD;AACA,oD;AACA,8B;AACA,kB;AACA,S;AACA,M;AACA,sC;AACA,qE;;AAEA,2C;AACA,oE;AACA,qE;AACA,wD;AACA,S;AACA,M;AACA,yC;AACA,wE;;AAEA,2C;AACA,gE;AACA,iE;AACA,oD;AACA,S;AACA,M;AACA,+B;AACA,4B;AACA,sC;AACA,iC;AACA,2B;AACA,wB;AACA,S;AACA,S;AACA,wB;AACA,M;AACA,0B;AACA,0D;AACA,iC;AACA,2B;AACA,4B;AACA,oE;AACA,4B;AACA,O;AACA,M;AACA,yB;AACA,mD;AACA,sC;AACA,qB;AACA,S;AACA,sB;AACA,M;AACA,0B;AACA,oD;AACA,4B;AACA,O;AACA,uB;AACA,M;AACA,4B;AACA,wB;AACA,wB;AACA,mD;AACA,sC;AACA,+C;AACA,+B;AACA,S;AACA,oD;AACA,M;AACA,sC;AACA,6C;AACA,M;AACA,kC;AACA,oD;AACA,iC;AACA,+B;AACA,S;AACA,O;AACA,M;AACA,2D;AACA,sB;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","file":"/packages/vsivsi_file-collection.js","sourcesContent":["/*\n* MIT Licensed\n* http://www.23developer.com/opensource\n* http://github.com/23/resumable.js\n* Steffen Tiedemann Christensen, steffen@23company.com\n*/\n\n(function(){\n\"use strict\";\n\n  var Resumable = function(opts){\n    if ( !(this instanceof Resumable) ) {\n      return new Resumable(opts);\n    }\n    this.version = 1.0;\n    // SUPPORTED BY BROWSER?\n    // Check if these features are support by the browser:\n    // - File object type\n    // - Blob object type\n    // - FileList object type\n    // - slicing files\n    this.support = (\n                   (typeof(File)!=='undefined')\n                   &&\n                   (typeof(Blob)!=='undefined')\n                   &&\n                   (typeof(FileList)!=='undefined')\n                   &&\n                   (!!Blob.prototype.webkitSlice||!!Blob.prototype.mozSlice||!!Blob.prototype.slice||false)\n                   );\n    if(!this.support) return(false);\n\n\n    // PROPERTIES\n    var $ = this;\n    $.files = [];\n    $.defaults = {\n      chunkSize:1*1024*1024,\n      forceChunkSize:false,\n      simultaneousUploads:3,\n      fileParameterName:'file',\n      throttleProgressCallbacks:0.5,\n      query:{},\n      headers:{},\n      preprocess:null,\n      method:'multipart',\n      prioritizeFirstAndLastChunk:false,\n      target:'/',\n      parameterNamespace:'',\n      testChunks:true,\n      generateUniqueIdentifier:null,\n      maxChunkRetries:undefined,\n      chunkRetryInterval:undefined,\n      permanentErrors:[400, 404, 415, 500, 501],\n      maxFiles:undefined,\n      withCredentials:false,\n      xhrTimeout:0,\n      maxFilesErrorCallback:function (files, errorCount) {\n        var maxFiles = $.getOpt('maxFiles');\n        alert('Please upload ' + maxFiles + ' file' + (maxFiles === 1 ? '' : 's') + ' at a time.');\n      },\n      minFileSize:1,\n      minFileSizeErrorCallback:function(file, errorCount) {\n        alert(file.fileName||file.name +' is too small, please upload files larger than ' + $h.formatSize($.getOpt('minFileSize')) + '.');\n      },\n      maxFileSize:undefined,\n      maxFileSizeErrorCallback:function(file, errorCount) {\n        alert(file.fileName||file.name +' is too large, please upload files less than ' + $h.formatSize($.getOpt('maxFileSize')) + '.');\n      },\n      fileType: [],\n      fileTypeErrorCallback: function(file, errorCount) {\n        alert(file.fileName||file.name +' has type not allowed, please upload files of type ' + $.getOpt('fileType') + '.');\n      }\n    };\n    $.opts = opts||{};\n    $.getOpt = function(o) {\n      var $opt = this;\n      // Get multiple option if passed an array\n      if(o instanceof Array) {\n        var options = {};\n        $h.each(o, function(option){\n          options[option] = $opt.getOpt(option);\n        });\n        return options;\n      }\n      // Otherwise, just return a simple option\n      if ($opt instanceof ResumableChunk) {\n        if (typeof $opt.opts[o] !== 'undefined') { return $opt.opts[o]; }\n        else { $opt = $opt.fileObj; }\n      }\n      if ($opt instanceof ResumableFile) {\n        if (typeof $opt.opts[o] !== 'undefined') { return $opt.opts[o]; }\n        else { $opt = $opt.resumableObj; }\n      }\n      if ($opt instanceof Resumable) {\n        if (typeof $opt.opts[o] !== 'undefined') { return $opt.opts[o]; }\n        else { return $opt.defaults[o]; }\n      }\n    };\n\n    // EVENTS\n    // catchAll(event, ...)\n    // fileSuccess(file), fileProgress(file), fileAdded(file, event), fileRetry(file), fileError(file, message),\n    // complete(), progress(), error(message, file), pause()\n    $.events = [];\n    $.on = function(event,callback){\n      $.events.push(event.toLowerCase(), callback);\n    };\n    $.fire = function(){\n      // `arguments` is an object, not array, in FF, so:\n      var args = [];\n      for (var i=0; i<arguments.length; i++) args.push(arguments[i]);\n      // Find event listeners, and support pseudo-event `catchAll`\n      var event = args[0].toLowerCase();\n      for (var i=0; i<=$.events.length; i+=2) {\n        if($.events[i]==event) $.events[i+1].apply($,args.slice(1));\n        if($.events[i]=='catchall') $.events[i+1].apply(null,args);\n      }\n      if(event=='fileerror') $.fire('error', args[2], args[1]);\n      if(event=='fileprogress') $.fire('progress');\n    };\n\n\n    // INTERNAL HELPER METHODS (handy, but ultimately not part of uploading)\n    var $h = {\n      stopEvent: function(e){\n        e.stopPropagation();\n        e.preventDefault();\n      },\n      each: function(o,callback){\n        if(typeof(o.length)!=='undefined') {\n          for (var i=0; i<o.length; i++) {\n            // Array or FileList\n            if(callback(o[i])===false) return;\n          }\n        } else {\n          for (i in o) {\n            // Object\n            if(callback(i,o[i])===false) return;\n          }\n        }\n      },\n      generateUniqueIdentifier:function(file){\n        var custom = $.getOpt('generateUniqueIdentifier');\n        if(typeof custom === 'function') {\n          return custom(file);\n        }\n        var relativePath = file.webkitRelativePath||file.fileName||file.name; // Some confusion in different versions of Firefox\n        var size = file.size;\n        return(size + '-' + relativePath.replace(/[^0-9a-zA-Z_-]/img, ''));\n      },\n      contains:function(array,test) {\n        var result = false;\n\n        $h.each(array, function(value) {\n          if (value == test) {\n            result = true;\n            return false;\n          }\n          return true;\n        });\n\n        return result;\n      },\n      formatSize:function(size){\n        if(size<1024) {\n          return size + ' bytes';\n        } else if(size<1024*1024) {\n          return (size/1024.0).toFixed(0) + ' KB';\n        } else if(size<1024*1024*1024) {\n          return (size/1024.0/1024.0).toFixed(1) + ' MB';\n        } else {\n          return (size/1024.0/1024.0/1024.0).toFixed(1) + ' GB';\n        }\n      },\n      getTarget:function(params){\n        var target = $.getOpt('target');\n        if(target.indexOf('?') < 0) {\n          target += '?';\n        } else {\n          target += '&';\n        }\n        return target + params.join('&');\n      }\n    };\n\n    var onDrop = function(event){\n      $h.stopEvent(event);\n\n      //handle dropped things as items if we can (this lets us deal with folders nicer in some cases)\n      if (event.dataTransfer && event.dataTransfer.items) {\n        loadFiles(event.dataTransfer.items, event);\n      }\n      //else handle them as files\n      else if (event.dataTransfer && event.dataTransfer.files) {\n        loadFiles(event.dataTransfer.files, event);\n      }\n    };\n    var preventDefault = function(e) {\n      e.preventDefault();\n    };\n\n    // INTERNAL METHODS (both handy and responsible for the heavy load)\n    /**\n     * @summary This function loops over the files passed in from a drag and drop operation and gets them ready for appendFilesFromFileList\n     *            It attempts to use FileSystem API calls to extract files and subfolders if the dropped items include folders\n     *            That capability is only currently available in Chrome, but if it isn't available it will just pass the items along to\n     *            appendFilesFromFileList (via enqueueFileAddition to help with asynchronous processing.)\n     * @param files {Array} - the File or Entry objects to be processed depending on your browser support\n     * @param event {Object} - the drop event object\n     * @param [queue] {Object} - an object to keep track of our progress processing the dropped items\n     * @param [path] {String} - the relative path from the originally selected folder to the current files if extracting files from subfolders\n     */\n    var loadFiles = function (files, event, queue, path){\n      //initialize the queue object if it doesn't exist\n      if (!queue) {\n        queue = {\n          total: 0,\n          files: [],\n          event: event\n        };\n      }\n\n      //update the total number of things we plan to process\n      updateQueueTotal(files.length, queue);\n\n      //loop over all the passed in objects checking if they are files or folders\n      for (var i = 0; i < files.length; i++) {\n        var file = files[i];\n        var entry, reader;\n\n        if (file.isFile || file.isDirectory) {\n          //this is an object we can handle below with no extra work needed up front\n          entry = file;\n        }\n        else if (file.getAsEntry) {\n          //get the file as an entry object if we can using the proposed HTML5 api (unlikely to get implemented by anyone)\n          entry = file.getAsEntry();\n        }\n        else if (file.webkitGetAsEntry) {\n          //get the file as an entry object if we can using the Chrome specific webkit implementation\n          entry = file.webkitGetAsEntry();\n        }\n        else if (typeof file.getAsFile === 'function') {\n          //if this is still a DataTransferItem object, get it as a file object\n          enqueueFileAddition(file.getAsFile(), queue, path);\n          //we just added this file object to the queue so we can go to the next object in the loop and skip the processing below\n          continue;\n        }\n        else if (File && file instanceof File) {\n          //this is already a file object so just queue it up and move on\n          enqueueFileAddition(file, queue, path);\n          //we just added this file object to the queue so we can go to the next object in the loop and skip the processing below\n          continue;\n        }\n        else {\n          //we can't do anything with this object, decrement the expected total and skip the processing below\n          updateQueueTotal(-1, queue);\n          continue;\n        }\n\n        if (!entry) {\n          //there isn't anything we can do with this so decrement the total expected\n          updateQueueTotal(-1, queue);\n        }\n        else if (entry.isFile) {\n          //this is handling to read an entry object representing a file, parsing the file object is asynchronous which is why we need the queue\n          //currently entry objects will only exist in this flow for Chrome\n          entry.file(function(file) {\n            enqueueFileAddition(file, queue, path);\n          }, function(err) {\n            console.warn(err);\n          });\n        }\n        else if (entry.isDirectory) {\n          //this is handling to read an entry object representing a folder, parsing the directory object is asynchronous which is why we need the queue\n          //currently entry objects will only exist in this flow for Chrome\n          reader = entry.createReader();\n\n            var newEntries = [];\n            //wrap the callback in another function so we can store the path in a closure\n            var readDir = function(path){\n                reader.readEntries(\n                    //success callback: read entries out of the directory\n                    function(entries){\n                        if (entries.length>0){\n                            //add these results to the array of all the new stuff\n                            for (var i=0; i<entries.length; i++) { newEntries.push(entries[i]); }\n                            //call this function again as all the results may not have been sent yet\n                            readDir(entry.fullPath);\n                        }\n                        else {\n                            //we have now gotten all the results in newEntries so let's process them recursively\n                            loadFiles(newEntries, event, queue, path);\n                            //this was a directory rather than a file so decrement the expected file count\n                            updateQueueTotal(-1, queue);\n                        }\n                    },\n                    //error callback, most often hit if there is a directory with nothing inside it\n                    function(err) {\n                        //this was a directory rather than a file so decrement the expected file count\n                        updateQueueTotal(-1, queue);\n                        console.warn(err);\n                    }\n                );\n            };\n        }\n      }\n    };\n\n    /**\n     * @summary Adjust the total number of files we are expecting to process\n     *          if decrementing and the new expected total is equal to the number processed, flush the queue\n     * @param addition {Number} - the number of additional files we expect to process (may be negative)\n     * @param queue {Object} - an object to keep track of our progress processing the dropped items\n     */\n    var updateQueueTotal = function(addition, queue){\n      queue.total += addition;\n\n      // If all the files we expect have shown up, then flush the queue.\n      if (queue.files.length === queue.total) {\n        appendFilesFromFileList(queue.files, queue.event);\n      }\n    };\n\n    /**\n     * @summary Add a file to the queue of processed files, if it brings the total up to the expected total, flush the queue\n     * @param file {Object} - File object to be passed along to appendFilesFromFileList eventually\n     * @param queue {Object} - an object to keep track of our progress processing the dropped items\n     * @param [path] {String} - the file's relative path from the originally dropped folder if we are parsing folder content (Chrome only for now)\n     */\n    var enqueueFileAddition = function(file, queue, path) {\n      //store the path to this file if it came in as part of a folder\n      if (path) file.relativePath = path + '/' + file.name;\n      queue.files.push(file);\n\n      // If all the files we expect have shown up, then flush the queue.\n      if (queue.files.length === queue.total) {\n        appendFilesFromFileList(queue.files, queue.event);\n      }\n    };\n\n    var appendFilesFromFileList = function(fileList, event){\n      // check for uploading too many files\n      var errorCount = 0;\n      var o = $.getOpt(['maxFiles', 'minFileSize', 'maxFileSize', 'maxFilesErrorCallback', 'minFileSizeErrorCallback', 'maxFileSizeErrorCallback', 'fileType', 'fileTypeErrorCallback']);\n      if (typeof(o.maxFiles)!=='undefined' && o.maxFiles<(fileList.length+$.files.length)) {\n        // if single-file upload, file is already added, and trying to add 1 new file, simply replace the already-added file\n        if (o.maxFiles===1 && $.files.length===1 && fileList.length===1) {\n          $.removeFile($.files[0]);\n        } else {\n          o.maxFilesErrorCallback(fileList, errorCount++);\n          return false;\n        }\n      }\n      var files = [];\n      $h.each(fileList, function(file){\n        var fileName = file.name;\n        if(o.fileType.length > 0){\n\t\t\tvar fileTypeFound = false;\n\t\t\tfor(var index in o.fileType){\n\t\t\t\tvar extension = '.' + o.fileType[index];\n\t\t\t\tif(fileName.indexOf(extension, fileName.length - extension.length) !== -1){\n\t\t\t\t\tfileTypeFound = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!fileTypeFound) {\n\t\t\t  o.fileTypeErrorCallback(file, errorCount++);\n\t\t\t  return false;\n\t\t\t}\n\t\t}\n\n        if (typeof(o.minFileSize)!=='undefined' && file.size<o.minFileSize) {\n          o.minFileSizeErrorCallback(file, errorCount++);\n          return false;\n        }\n        if (typeof(o.maxFileSize)!=='undefined' && file.size>o.maxFileSize) {\n          o.maxFileSizeErrorCallback(file, errorCount++);\n          return false;\n        }\n\n        function addFile(uniqueIdentifier){\n          if (!$.getFromUniqueIdentifier(uniqueIdentifier)) {(function(){\n            file.uniqueIdentifier = uniqueIdentifier;\n            var f = new ResumableFile($, file, uniqueIdentifier);\n            $.files.push(f);\n            files.push(f);\n            f.container = (typeof event != 'undefined' ? event.srcElement : null);\n            window.setTimeout(function(){\n              $.fire('fileAdded', f, event)\n            },0);\n          })()};\n        }\n        // directories have size == 0\n        var uniqueIdentifier = $h.generateUniqueIdentifier(file)\n        if(uniqueIdentifier && typeof uniqueIdentifier.done === 'function' && typeof uniqueIdentifier.fail === 'function'){\n          uniqueIdentifier\n          .done(function(uniqueIdentifier){\n              addFile(uniqueIdentifier);\n          })\n          .fail(function(){\n              addFile();\n          });\n        }else{\n          addFile(uniqueIdentifier);\n        }\n\n      });\n      window.setTimeout(function(){\n        $.fire('filesAdded', files)\n      },0);\n    };\n\n    // INTERNAL OBJECT TYPES\n    function ResumableFile(resumableObj, file, uniqueIdentifier){\n      var $ = this;\n      $.opts = {};\n      $.getOpt = resumableObj.getOpt;\n      $._prevProgress = 0;\n      $.resumableObj = resumableObj;\n      $.file = file;\n      $.fileName = file.fileName||file.name; // Some confusion in different versions of Firefox\n      $.size = file.size;\n      $.relativePath = file.webkitRelativePath || file.relativePath || $.fileName;\n      $.uniqueIdentifier = uniqueIdentifier;\n      $._pause = false;\n      $.container = '';\n      var _error = uniqueIdentifier !== undefined;\n\n      // Callback when something happens within the chunk\n      var chunkEvent = function(event, message){\n        // event can be 'progress', 'success', 'error' or 'retry'\n        switch(event){\n        case 'progress':\n          $.resumableObj.fire('fileProgress', $);\n          break;\n        case 'error':\n          $.abort();\n          _error = true;\n          $.chunks = [];\n          $.resumableObj.fire('fileError', $, message);\n          break;\n        case 'success':\n          if(_error) return;\n          $.resumableObj.fire('fileProgress', $); // it's at least progress\n          if($.isComplete()) {\n            $.resumableObj.fire('fileSuccess', $, message);\n          }\n          break;\n        case 'retry':\n          $.resumableObj.fire('fileRetry', $);\n          break;\n        }\n      };\n\n      // Main code to set up a file object with chunks,\n      // packaged to be able to handle retries if needed.\n      $.chunks = [];\n      $.abort = function(){\n        // Stop current uploads\n        var abortCount = 0;\n        $h.each($.chunks, function(c){\n          if(c.status()=='uploading') {\n            c.abort();\n            abortCount++;\n          }\n        });\n        if(abortCount>0) $.resumableObj.fire('fileProgress', $);\n      };\n      $.cancel = function(){\n        // Reset this file to be void\n        var _chunks = $.chunks;\n        $.chunks = [];\n        // Stop current uploads\n        $h.each(_chunks, function(c){\n          if(c.status()=='uploading')  {\n            c.abort();\n            $.resumableObj.uploadNextChunk();\n          }\n        });\n        $.resumableObj.removeFile($);\n        $.resumableObj.fire('fileProgress', $);\n      };\n      $.retry = function(){\n        $.bootstrap();\n        var firedRetry = false;\n        $.resumableObj.on('chunkingComplete', function(){\n          if(!firedRetry) $.resumableObj.upload();\n          firedRetry = true;\n        });\n      };\n      $.bootstrap = function(){\n        $.abort();\n        _error = false;\n        // Rebuild stack of chunks from file\n        $.chunks = [];\n        $._prevProgress = 0;\n        var round = $.getOpt('forceChunkSize') ? Math.ceil : Math.floor;\n        var maxOffset = Math.max(round($.file.size/$.getOpt('chunkSize')),1);\n        for (var offset=0; offset<maxOffset; offset++) {(function(offset){\n            window.setTimeout(function(){\n                $.chunks.push(new ResumableChunk($.resumableObj, $, offset, chunkEvent));\n                $.resumableObj.fire('chunkingProgress',$,offset/maxOffset);\n            },0);\n        })(offset)}\n        window.setTimeout(function(){\n            $.resumableObj.fire('chunkingComplete',$);\n        },0);\n      };\n      $.progress = function(){\n        if(_error) return(1);\n        // Sum up progress across everything\n        var ret = 0;\n        var error = false;\n        $h.each($.chunks, function(c){\n          if(c.status()=='error') error = true;\n          ret += c.progress(true); // get chunk progress relative to entire file\n        });\n        ret = (error ? 1 : (ret>0.99999 ? 1 : ret));\n        ret = Math.max($._prevProgress, ret); // We don't want to lose percentages when an upload is paused\n        $._prevProgress = ret;\n        return(ret);\n      };\n      $.isUploading = function(){\n        var uploading = false;\n        $h.each($.chunks, function(chunk){\n          if(chunk.status()=='uploading') {\n            uploading = true;\n            return(false);\n          }\n        });\n        return(uploading);\n      };\n      $.isComplete = function(){\n        var outstanding = false;\n        $h.each($.chunks, function(chunk){\n          var status = chunk.status();\n          if(status=='pending' || status=='uploading' || chunk.preprocessState === 1) {\n            outstanding = true;\n            return(false);\n          }\n        });\n        return(!outstanding);\n      };\n      $.pause = function(pause){\n          if(typeof(pause)==='undefined'){\n              $._pause = ($._pause ? false : true);\n          }else{\n              $._pause = pause;\n          }\n      };\n      $.isPaused = function() {\n        return $._pause;\n      };\n\n\n      // Bootstrap and return\n      $.resumableObj.fire('chunkingStart', $);\n      $.bootstrap();\n      return(this);\n    }\n\n\n    function ResumableChunk(resumableObj, fileObj, offset, callback){\n      var $ = this;\n      $.opts = {};\n      $.getOpt = resumableObj.getOpt;\n      $.resumableObj = resumableObj;\n      $.fileObj = fileObj;\n      $.fileObjSize = fileObj.size;\n      $.fileObjType = fileObj.file.type;\n      $.offset = offset;\n      $.callback = callback;\n      $.lastProgressCallback = (new Date);\n      $.tested = false;\n      $.retries = 0;\n      $.pendingRetry = false;\n      $.preprocessState = 0; // 0 = unprocessed, 1 = processing, 2 = finished\n\n      // Computed properties\n      var chunkSize = $.getOpt('chunkSize');\n      $.loaded = 0;\n      $.startByte = $.offset*chunkSize;\n      $.endByte = Math.min($.fileObjSize, ($.offset+1)*chunkSize);\n      if ($.fileObjSize-$.endByte < chunkSize && !$.getOpt('forceChunkSize')) {\n        // The last chunk will be bigger than the chunk size, but less than 2*chunkSize\n        $.endByte = $.fileObjSize;\n      }\n      $.xhr = null;\n\n      // test() makes a GET request without any data to see if the chunk has already been uploaded in a previous session\n      $.test = function(){\n        // Set up request and listen for event\n        $.xhr = new XMLHttpRequest();\n\n        var testHandler = function(e){\n          $.tested = true;\n          var status = $.status();\n          if(status=='success') {\n            $.callback(status, $.message());\n            $.resumableObj.uploadNextChunk();\n          } else {\n            $.send();\n          }\n        };\n        $.xhr.addEventListener('load', testHandler, false);\n        $.xhr.addEventListener('error', testHandler, false);\n        $.xhr.addEventListener('timeout', testHandler, false);\n\n        // Add data from the query options\n        var params = [];\n        var parameterNamespace = $.getOpt('parameterNamespace');\n        var customQuery = $.getOpt('query');\n        if(typeof customQuery == 'function') customQuery = customQuery($.fileObj, $);\n        $h.each(customQuery, function(k,v){\n          params.push([encodeURIComponent(parameterNamespace+k), encodeURIComponent(v)].join('='));\n        });\n        // Add extra data to identify chunk\n        params.push([parameterNamespace+'resumableChunkNumber', encodeURIComponent($.offset+1)].join('='));\n        params.push([parameterNamespace+'resumableChunkSize', encodeURIComponent($.getOpt('chunkSize'))].join('='));\n        params.push([parameterNamespace+'resumableCurrentChunkSize', encodeURIComponent($.endByte - $.startByte)].join('='));\n        params.push([parameterNamespace+'resumableTotalSize', encodeURIComponent($.fileObjSize)].join('='));\n        params.push([parameterNamespace+'resumableType', encodeURIComponent($.fileObjType)].join('='));\n        params.push([parameterNamespace+'resumableIdentifier', encodeURIComponent($.fileObj.uniqueIdentifier)].join('='));\n        params.push([parameterNamespace+'resumableFilename', encodeURIComponent($.fileObj.fileName)].join('='));\n        params.push([parameterNamespace+'resumableRelativePath', encodeURIComponent($.fileObj.relativePath)].join('='));\n        params.push([parameterNamespace+'resumableTotalChunks', encodeURIComponent($.fileObj.chunks.length)].join('='));\n        // Append the relevant chunk and send it\n        $.xhr.open('GET', $h.getTarget(params));\n        $.xhr.timeout = $.getOpt('xhrTimeout');\n        $.xhr.withCredentials = $.getOpt('withCredentials');\n        // Add data from header options\n        $h.each($.getOpt('headers'), function(k,v) {\n          $.xhr.setRequestHeader(k, v);\n        });\n        $.xhr.send(null);\n      };\n\n      $.preprocessFinished = function(){\n        $.preprocessState = 2;\n        $.send();\n      };\n\n      // send() uploads the actual data in a POST call\n      $.send = function(){\n        var preprocess = $.getOpt('preprocess');\n        if(typeof preprocess === 'function') {\n          switch($.preprocessState) {\n          case 0: $.preprocessState = 1; preprocess($); return;\n          case 1: return;\n          case 2: break;\n          }\n        }\n        if($.getOpt('testChunks') && !$.tested) {\n          $.test();\n          return;\n        }\n\n        // Set up request and listen for event\n        $.xhr = new XMLHttpRequest();\n\n        // Progress\n        $.xhr.upload.addEventListener('progress', function(e){\n          if( (new Date) - $.lastProgressCallback > $.getOpt('throttleProgressCallbacks') * 1000 ) {\n            $.callback('progress');\n            $.lastProgressCallback = (new Date);\n          }\n          $.loaded=e.loaded||0;\n        }, false);\n        $.loaded = 0;\n        $.pendingRetry = false;\n        $.callback('progress');\n\n        // Done (either done, failed or retry)\n        var doneHandler = function(e){\n          var status = $.status();\n          if(status=='success'||status=='error') {\n            $.callback(status, $.message());\n            $.resumableObj.uploadNextChunk();\n          } else {\n            $.callback('retry', $.message());\n            $.abort();\n            $.retries++;\n            var retryInterval = $.getOpt('chunkRetryInterval');\n            if(retryInterval !== undefined) {\n              $.pendingRetry = true;\n              setTimeout($.send, retryInterval);\n            } else {\n              $.send();\n            }\n          }\n        };\n        $.xhr.addEventListener('load', doneHandler, false);\n        $.xhr.addEventListener('error', doneHandler, false);\n        $.xhr.addEventListener('timeout', doneHandler, false);\n\n        // Set up the basic query data from Resumable\n        var query = {\n          resumableChunkNumber: $.offset+1,\n          resumableChunkSize: $.getOpt('chunkSize'),\n          resumableCurrentChunkSize: $.endByte - $.startByte,\n          resumableTotalSize: $.fileObjSize,\n          resumableType: $.fileObjType,\n          resumableIdentifier: $.fileObj.uniqueIdentifier,\n          resumableFilename: $.fileObj.fileName,\n          resumableRelativePath: $.fileObj.relativePath,\n          resumableTotalChunks: $.fileObj.chunks.length\n        };\n        // Mix in custom data\n        var customQuery = $.getOpt('query');\n        if(typeof customQuery == 'function') customQuery = customQuery($.fileObj, $);\n        $h.each(customQuery, function(k,v){\n          query[k] = v;\n        });\n\n        var func   = ($.fileObj.file.slice ? 'slice' : ($.fileObj.file.mozSlice ? 'mozSlice' : ($.fileObj.file.webkitSlice ? 'webkitSlice' : 'slice'))),\n        bytes  = $.fileObj.file[func]($.startByte,$.endByte),\n        data   = null,\n        target = $.getOpt('target');\n\n        var parameterNamespace = $.getOpt('parameterNamespace');\n        if ($.getOpt('method') === 'octet') {\n          // Add data from the query options\n          data = bytes;\n          var params = [];\n          $h.each(query, function(k,v){\n            params.push([encodeURIComponent(parameterNamespace+k), encodeURIComponent(v)].join('='));\n          });\n          target = $h.getTarget(params);\n        } else {\n          // Add data from the query options\n          data = new FormData();\n          $h.each(query, function(k,v){\n            data.append(parameterNamespace+k,v);\n          });\n          data.append(parameterNamespace+$.getOpt('fileParameterName'), bytes);\n        }\n\n        $.xhr.open('POST', target);\n        $.xhr.timeout = $.getOpt('xhrTimeout');\n        $.xhr.withCredentials = $.getOpt('withCredentials');\n        // Add data from header options\n        $h.each($.getOpt('headers'), function(k,v) {\n          $.xhr.setRequestHeader(k, v);\n        });\n        $.xhr.send(data);\n      };\n      $.abort = function(){\n        // Abort and reset\n        if($.xhr) $.xhr.abort();\n        $.xhr = null;\n      };\n      $.status = function(){\n        // Returns: 'pending', 'uploading', 'success', 'error'\n        if($.pendingRetry) {\n          // if pending retry then that's effectively the same as actively uploading,\n          // there might just be a slight delay before the retry starts\n          return('uploading');\n        } else if(!$.xhr) {\n          return('pending');\n        } else if($.xhr.readyState<4) {\n          // Status is really 'OPENED', 'HEADERS_RECEIVED' or 'LOADING' - meaning that stuff is happening\n          return('uploading');\n        } else {\n          if($.xhr.status==200) {\n            // HTTP 200, perfect\n            return('success');\n          } else if($h.contains($.getOpt('permanentErrors'), $.xhr.status) || $.retries >= $.getOpt('maxChunkRetries')) {\n            // HTTP 415/500/501, permanent error\n            return('error');\n          } else {\n            // this should never happen, but we'll reset and queue a retry\n            // a likely case for this would be 503 service unavailable\n            $.abort();\n            return('pending');\n          }\n        }\n      };\n      $.message = function(){\n        return($.xhr ? $.xhr.responseText : '');\n      };\n      $.progress = function(relative){\n        if(typeof(relative)==='undefined') relative = false;\n        var factor = (relative ? ($.endByte-$.startByte)/$.fileObjSize : 1);\n        if($.pendingRetry) return(0);\n        var s = $.status();\n        switch(s){\n        case 'success':\n        case 'error':\n          return(1*factor);\n        case 'pending':\n          return(0*factor);\n        default:\n          return($.loaded/($.endByte-$.startByte)*factor);\n        }\n      };\n      return(this);\n    }\n\n    // QUEUE\n    $.uploadNextChunk = function(){\n      var found = false;\n\n      // In some cases (such as videos) it's really handy to upload the first\n      // and last chunk of a file quickly; this let's the server check the file's\n      // metadata and determine if there's even a point in continuing.\n      if ($.getOpt('prioritizeFirstAndLastChunk')) {\n        $h.each($.files, function(file){\n          if(file.chunks.length && file.chunks[0].status()=='pending' && file.chunks[0].preprocessState === 0) {\n            file.chunks[0].send();\n            found = true;\n            return(false);\n          }\n          if(file.chunks.length>1 && file.chunks[file.chunks.length-1].status()=='pending' && file.chunks[file.chunks.length-1].preprocessState === 0) {\n            file.chunks[file.chunks.length-1].send();\n            found = true;\n            return(false);\n          }\n        });\n        if(found) return(true);\n      }\n\n      // Now, simply look for the next, best thing to upload\n      $h.each($.files, function(file){\n        if(file.isPaused()===false){\n         $h.each(file.chunks, function(chunk){\n           if(chunk.status()=='pending' && chunk.preprocessState === 0) {\n             chunk.send();\n             found = true;\n             return(false);\n           }\n          });\n        }\n        if(found) return(false);\n      });\n      if(found) return(true);\n\n      // The are no more outstanding chunks to upload, check is everything is done\n      var outstanding = false;\n      $h.each($.files, function(file){\n        if(!file.isComplete()) {\n          outstanding = true;\n          return(false);\n        }\n      });\n      if(!outstanding) {\n        // All chunks have been uploaded, complete\n        $.fire('complete');\n      }\n      return(false);\n    };\n\n\n    // PUBLIC METHODS FOR RESUMABLE.JS\n    $.assignBrowse = function(domNodes, isDirectory){\n      if(typeof(domNodes.length)=='undefined') domNodes = [domNodes];\n\n      $h.each(domNodes, function(domNode) {\n        var input;\n        if(domNode.tagName==='INPUT' && domNode.type==='file'){\n          input = domNode;\n        } else {\n          input = document.createElement('input');\n          input.setAttribute('type', 'file');\n          input.style.display = 'none';\n          domNode.addEventListener('click', function(){\n            input.style.opacity = 0;\n            input.style.display='block';\n            input.focus();\n            input.click();\n            input.style.display='none';\n          }, false);\n          domNode.appendChild(input);\n        }\n        var maxFiles = $.getOpt('maxFiles');\n        if (typeof(maxFiles)==='undefined'||maxFiles!=1){\n          input.setAttribute('multiple', 'multiple');\n        } else {\n          input.removeAttribute('multiple');\n        }\n        if(isDirectory){\n          input.setAttribute('webkitdirectory', 'webkitdirectory');\n        } else {\n          input.removeAttribute('webkitdirectory');\n        }\n        // When new files are added, simply append them to the overall list\n        input.addEventListener('change', function(e){\n          appendFilesFromFileList(e.target.files,e);\n          e.target.value = '';\n        }, false);\n      });\n    };\n    $.assignDrop = function(domNodes){\n      if(typeof(domNodes.length)=='undefined') domNodes = [domNodes];\n\n      $h.each(domNodes, function(domNode) {\n        domNode.addEventListener('dragover', preventDefault, false);\n        domNode.addEventListener('dragenter', preventDefault, false);\n        domNode.addEventListener('drop', onDrop, false);\n      });\n    };\n    $.unAssignDrop = function(domNodes) {\n      if (typeof(domNodes.length) == 'undefined') domNodes = [domNodes];\n\n      $h.each(domNodes, function(domNode) {\n        domNode.removeEventListener('dragover', preventDefault);\n        domNode.removeEventListener('dragenter', preventDefault);\n        domNode.removeEventListener('drop', onDrop);\n      });\n    };\n    $.isUploading = function(){\n      var uploading = false;\n      $h.each($.files, function(file){\n        if (file.isUploading()) {\n          uploading = true;\n          return(false);\n        }\n      });\n      return(uploading);\n    };\n    $.upload = function(){\n      // Make sure we don't start too many uploads at once\n      if($.isUploading()) return;\n      // Kick off the queue\n      $.fire('uploadStart');\n      for (var num=1; num<=$.getOpt('simultaneousUploads'); num++) {\n        $.uploadNextChunk();\n      }\n    };\n    $.pause = function(){\n      // Resume all chunks currently being uploaded\n      $h.each($.files, function(file){\n        file.abort();\n      });\n      $.fire('pause');\n    };\n    $.cancel = function(){\n      for(var i = $.files.length - 1; i >= 0; i--) {\n        $.files[i].cancel();\n      }\n      $.fire('cancel');\n    };\n    $.progress = function(){\n      var totalDone = 0;\n      var totalSize = 0;\n      // Resume all chunks currently being uploaded\n      $h.each($.files, function(file){\n        totalDone += file.progress()*file.size;\n        totalSize += file.size;\n      });\n      return(totalSize>0 ? totalDone/totalSize : 0);\n    };\n    $.addFile = function(file, event){\n      appendFilesFromFileList([file], event);\n    };\n    $.removeFile = function(file){\n      for(var i = $.files.length - 1; i >= 0; i--) {\n        if($.files[i] === file) {\n          $.files.splice(i, 1);\n        }\n      }\n    };\n    $.getFromUniqueIdentifier = function(uniqueIdentifier){\n      var ret = false;\n      $h.each($.files, function(f){\n        if(f.uniqueIdentifier==uniqueIdentifier) ret = f;\n      });\n      return(ret);\n    };\n    $.getSize = function(){\n      var totalSize = 0;\n      $h.each($.files, function(file){\n        totalSize += file.size;\n      });\n      return(totalSize);\n    };\n\n    return(this);\n  };\n\n\n  // Node.js-style export for Node and Component\n  if (typeof module != 'undefined') {\n    module.exports = Resumable;\n  } else if (typeof define === \"function\" && define.amd) {\n    // AMD/requirejs: Define the module\n    define(function(){\n      return Resumable;\n    });\n  } else {\n    // Browser: Expose to window\n    window.Resumable = Resumable;\n  }\n\n})();\n","############################################################################\n#     Copyright (C) 2014-2015 by Vaughn Iverson\n#     fileCollection is free software released under the MIT/X11 license.\n#     See included LICENSE file for details.\n############################################################################\n\nshare.defaultChunkSize = 2*1024*1024 - 1024\nshare.defaultRoot = 'fs'\n\nshare.insert_func = (file = {}, chunkSize) ->\n   try\n      id = new Meteor.Collection.ObjectID(\"#{file._id}\")\n   catch\n      id = new Meteor.Collection.ObjectID()\n   subFile = {}\n   subFile._id = id\n   subFile.length = 0\n   subFile.md5 = 'd41d8cd98f00b204e9800998ecf8427e'\n   subFile.uploadDate = new Date()\n   subFile.chunkSize = chunkSize\n   subFile.filename = file.filename ? ''\n   subFile.metadata = file.metadata ? {}\n   subFile.aliases = file.aliases ? []\n   subFile.contentType = file.contentType ? 'application/octet-stream'\n   return subFile\n","############################################################################\n#     Copyright (C) 2014-2015 by Vaughn Iverson\n#     fileCollection is free software released under the MIT/X11 license.\n#     See included LICENSE file for details.\n############################################################################\n\nif Meteor.isClient\n\n   # This is a polyfill for bind(), added to make phantomjs 1.9.7 work\n   unless Function.prototype.bind\n      Function.prototype.bind = (oThis) ->\n         if typeof this isnt \"function\"\n            # closest thing possible to the ECMAScript 5 internal IsCallable function\n            throw new TypeError(\"Function.prototype.bind - what is trying to be bound is not callable\")\n\n         aArgs = Array.prototype.slice.call arguments, 1\n         fToBind = this\n         fNOP = () ->\n         fBound = () ->\n            func = if (this instanceof fNOP and oThis) then this else oThis\n            return fToBind.apply(func, aArgs.concat(Array.prototype.slice.call(arguments)))\n\n         fNOP.prototype = this.prototype\n         fBound.prototype = new fNOP()\n         return fBound\n\n   share.setup_resumable = () ->\n      r = new Resumable\n         target: \"#{@baseURL}/_resumable\"\n         generateUniqueIdentifier: (file) -> \"#{new Meteor.Collection.ObjectID()}\"\n         fileParameterName: 'file'\n         chunkSize: @chunkSize\n         testChunks: true\n         permanentErrors: [204, 404, 415, 500, 501]\n         simultaneousUploads: 3\n         maxFiles: undefined\n         maxFilesErrorCallback: undefined\n         prioritizeFirstAndLastChunk: false\n         query: undefined\n         headers: {}\n\n      unless r.support\n         console.error \"resumable.js not supported by this Browser, uploads will be disabled\"\n         @resumable = null\n      else\n         @resumable = r","############################################################################\n#     Copyright (C) 2014-2015 by Vaughn Iverson\n#     fileCollection is free software released under the MIT/X11 license.\n#     See included LICENSE file for details.\n############################################################################\n\nif Meteor.isClient\n\n   class FileCollection extends Mongo.Collection\n\n      constructor: (@root = share.defaultRoot, options = {}) ->\n         unless @ instanceof FileCollection\n            return new FileCollection(root, options)\n\n         unless @ instanceof Mongo.Collection\n            throw new Error 'The global definition of Mongo.Collection has changed since the file-collection package was loaded. Please ensure that any packages that redefine Mongo.Collection are loaded before file-collection.'\n\n         if typeof @root is 'object'\n            options = @root\n            @root = share.defaultRoot\n\n         @base = @root\n         @baseURL = options.baseURL ? \"/gridfs/#{@root}\"\n         @chunkSize = options.chunkSize ? share.defaultChunkSize\n         super @root + '.files', { idGeneration: 'MONGO' }\n\n         # This call sets up the optional support for resumable.js\n         # See the resumable.coffee file for more information\n         if options.resumable\n            share.setup_resumable.bind(@)()\n\n      # remove works as-is. No modifications necessary so it currently goes straight to super\n\n      # Insert only creates an empty (but valid) gridFS file. To put data into it from a client,\n      # you need to use an HTTP POST or PUT after the record is inserted. For security reasons,\n      # you shouldn't be able to POST or PUT to a file that hasn't been inserted.\n\n      insert: (file, callback = undefined) ->\n         # This call ensures that a full gridFS file document\n         # gets built from whatever is provided\n         file = share.insert_func file, @chunkSize\n         super file, callback\n\n      allow: () ->\n        throw new Error \"File Collection Allow rules may not be set in client code.\"\n\n      deny: () ->\n        throw new Error \"File Collection Deny rules may not be set in client code.\"\n\n      upsert: () ->\n         throw new Error \"File Collections do not support 'upsert'\"\n\n      update: () ->\n         throw new Error \"File Collections do not support 'update' on client, use method calls instead\"\n\n      findOneStream: () ->\n         throw new Error \"File Collections do not support 'findOneStream' in client code.\"\n\n      upsertStream: () ->\n         throw new Error \"File Collections do not support 'upsertStream' in client code.\"\n\n      importFile: () ->\n         throw new Error \"File Collections do not support 'importFile' in client code.\"\n\n      exportFile: () ->\n         throw new Error \"File Collections do not support 'exportFile' in client code.\"\n"]}